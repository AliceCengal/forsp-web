{
  "std": {
    "name": "std.fp",
    "cts": "std",
    "uts": "lxqb7nn6",
    "content": "(\r\n  (>x x)                               >force\r\n  (>x <x <x)                           >dup\r\n  (>_)                                 >drop\r\n  (>x >y <x <y)                        >swap\r\n\r\n  ('())                                >nil\r\n  ('() eq)                             >null?\r\n\r\n  (>x x cswap >_ >x x)                 >if\r\n  (>f >t >c >fn <f <t <c fn)           >endif\r\n\r\n  (>f (>x (<x x) f) dup force)         >Y\r\n  (>g (<g Y))                          >rec\r\n\r\n  (tag 1 eq)                           >atom?\r\n  (tag 2 eq)                           >num?\r\n  (tag 3 eq)                           >pair?\r\n\r\n  ;; bitwise ops\r\n\r\n  ;; >b-nor is primitive\r\n  (dup b-nor swap dup b-nor b-nor)     >b-and\r\n  (b-nor dup b-nor)                    >b-or\r\n  (dup b-nor)                          >b-not\r\n\r\n  ;; List\r\n\r\n  (\r\n    >thing\r\n    <if (<thing tag 0 eq)\r\n      #t\r\n      (\r\n        <if (<thing tag 3 eq)\r\n          #t\r\n          '()\r\n        endif\r\n      )\r\n    endif\r\n  )                                    >list?\r\n\r\n  ; length [ list -> num ]\r\n  (\r\n    >self >list\r\n    <if (<list null?)\r\n      0\r\n      (<list cdr self 1 +)\r\n    endif\r\n  ) rec                                >length\r\n\r\n  ; explode [ list[n] -> n[ val ] ]\r\n  (\r\n    >self >list\r\n    <if (<list null?)\r\n      ()\r\n      (<list cdr self <list car)\r\n    endif\r\n  ) rec                                >explode\r\n\r\n  ; implode [ n n[ val ] -> list[n] ]\r\n  (\r\n    >self >n\r\n    <if (0 <n eq)\r\n      nil\r\n      (>tmp <n 1 - self <tmp cons)\r\n    endif\r\n  ) rec                                >implode\r\n\r\n  ;; Dictionary\r\n\r\n  (\r\n    >maybe-dict\r\n    <if (<maybe-dict pair?)\r\n      (\r\n        <if (<maybe-dict car pair?)\r\n          (\r\n            <if (<maybe-dict car car atom?)\r\n              #t\r\n              '()\r\n            endif\r\n          )\r\n          '()\r\n        endif\r\n      )\r\n      '()\r\n    endif\r\n  )                                    >dict?\r\n\r\n  ; dict-get [ key dict -> value? ]\r\n  (\r\n    >self >key >dict\r\n    <if (<dict null?)\r\n      nil\r\n      (\r\n        <if (<dict car car <key eq)\r\n          (<dict car cdr)\r\n          (<dict cdr <key self)\r\n        endif\r\n      )\r\n    endif\r\n  ) rec                                >dict-get\r\n\r\n  ; dict-set [ value key dict -> dict ]\r\n  (\r\n    >self >dict >key >value\r\n  ) rec                                >dict-set\r\n\r\n  (\r\n    \r\n  ) rec >dict-nil\r\n\r\n  ;; String\r\n\r\n  (tag 6 eq)                           >string?\r\n\r\n)"
  },
  "tutorial": {
    "name": "tutorial.fp",
    "cts": "tutorial",
    "uts": "lxqb7nn7",
    "content": "(\r\n  ;; This tutorial is adapted from (https://github.com/xorvoid/forsp)\r\n\r\n  ; Welcome to Forsp: A Forth+Lisp Hybrid Lambda Calculus Language\r\n  ;\r\n  ; As you can see, comment lines always start with the ';' semicolon character.\r\n  ; Also, all code is inside () braces. Actually, all code is an S-Expression, but\r\n  ; if you don't understand what that means, it's okay.\r\n  ;\r\n  ; In Forsp, we have a value stack. We can print it out as follows:\r\n\r\n  stack print ; ()\r\n\r\n  ; This should print a pair of parenthesis which means that the stack is empty.\r\n  ; Let's put something on the stack\r\n\r\n  5\r\n\r\n  ; And now let's print the stack again\r\n\r\n  stack print ; (5)\r\n\r\n  ; Now we have something! Let's put on a few more numbers\r\n\r\n  4 3\r\n\r\n  ; Now we have something! Let's put on a few more numbers\r\n\r\n  stack print ; (3 4 5)\r\n\r\n  ; A stack is LIFO order, or Last-In-First-Off. This means that the next value\r\n  ; to be removed from the stack will be 3. Let's \"print\" and find out.\r\n\r\n  print        ; 3\r\n  stack print  ; (4 5)\r\n\r\n  ; Checks out!\r\n  ; Let's try arithmetic!\r\n\r\n  * print     ; 20\r\n  stack print ; ()\r\n\r\n  ; The * operation multiplies the top-two values on the stack and then pushes\r\n  ; it back to stack. Then \"print\" prints the value, leaving the stack empty.\r\n\r\n  ; Sometimes working only with stack values is challenging. Luckily Forsp \r\n  ; has variables as well. We can POP the stack and store to a variable as \r\n  ; follows:\r\n\r\n  5 >my-variable\r\n  stack print ; ()\r\n\r\n  ; Now \"my-variable\" is bound to 5. To PUSH a value onto the stack from a \r\n  ; variable we can do the following:\r\n\r\n  <my-variable\r\n  stack print ; (5)\r\n  >_\r\n  \r\n  ; Coolio. Notice that we bound the variable \"_\" to remove the value from the \r\n  ; stack. Now, say we wanted to square \"my-variable\". we could to the following:\r\n\r\n  <my-variable <my-variable * print ; 25\r\n\r\n  ; Forsp also has function abstraction. They are simply () parenthesis grouping.\r\n\r\n  (>x <x <x *)\r\n  stack print  ; (CLOSURE<(quote x pop quote x push quote x push *)>)\r\n\r\n  ; What's this scary value on the stack now? When we build a function with (), \r\n  ; it forms a lexical closure around the current environment. If you prefer, \r\n  ; you can just think of \"CLOSURE\" as a \"callable function value\".\r\n\r\n  ; Fair enough, but how do we call it? As it turns out \"print\" and \"stack\" are \r\n  ; both functions. To call a function in Forsp, you simply write the function's\r\n  ; name. But, our function has no name yet. So, let's give it one by popping it \r\n  ; and binding to a variable name!\r\n\r\n  >square\r\n\r\n  ; And lets call it on an argument:\r\n\r\n  6 square\r\n  stack print ; 36\r\n\r\n  ; How cool! It should be easy enough to understand the function definition: \r\n  ; ($x ^x ^x *). Pop and bind \"x\". Push \"x\". Push \"x\" again. Call the \"*\" function.\r\n\r\n  ; Sometimes you need to refer to some data that you don't want evaluated.\r\n  ; For this, you can simply quote the value:\r\n\r\n  'something\r\n  '(1 2 3)\r\n  '(abc (1 foo) ())\r\n  stack print ;  ((abc (1 foo) ()) (1 2 3) something 36)\r\n\r\n  ; You can also write \"quote\" verbosely:\r\n\r\n  quote other\r\n  stack print ; (other (abc (1 foo) ()) (1 2 3) something 36)\r\n\r\n  ; Let's define another function to remove values for the stack, and use it\r\n  ; to cleanup the stack\r\n\r\n  (>_) >drop\r\n  drop drop drop drop drop\r\n\r\n  ; Believe it or now, this is ALL of Forsp's syntax and semantics!\r\n\r\n\r\n  ; Forsp has only a small number of built-in function primitives:\r\n  ; ---------------------------------------------------------------\r\n  ;\r\n  ;   CORE: Primitives needed to self-implement\r\n  ;\r\n  ;     primitive [args]          |  description                                      | example usage\r\n  ;     --------------------------|---------------------------------------------------|--------------\r\n  ;     push  [$name]             |  resolve \"name\" in environment and push           | 'foo push\r\n  ;     pop   [$name $val]        |  bind \"val\" to \"name\" in environment              | 'foo pop\r\n  ;     eq    [$a $b]             |  if \"a\" and \"b\" are equal, then \"t\", else \"()\"    | 'a 'b eq\r\n  ;     cons  [$fst $snd]         |  construct a pair from \"fst\" and \"snd\"            | '(2 3) 1 cons\r\n  ;     car   [$pair]             |  extract the first element of a pair              | '(1 2 3) car\r\n  ;     cdr   [$pair]             |  extract the second element of a pair             | '(1 2 3) cdr\r\n  ;     cswap [$cond $a $b]       |  if cond is \"t\" then perform a swap               | 1 2 't cswap\r\n  ;     tag   [$obj]              |  query the type-tag of any object                 | ^tag tag\r\n  ;     read  []                  |  read an s-expression from input data             | read\r\n  ;     print [$obj]              |  print an object as an s-expression               | '(foo bar) print\r\n  ;\r\n  ;   EXTRA: Additional primitives that are not strictly needed by useful to have\r\n  ;\r\n  ;     primitive [args]          |  description                                      | example usage\r\n  ;     --------------------------|---------------------------------------------------|--------------\r\n  ;     stack                     |  push the \"stack\" onto the stack: cons'ing self   | stack\r\n  ;     env                       |  push the \"env\" onto the stack                    | env\r\n  ;     -    [$b $a]              |  push the result of \"a-b\" (subtraction)           | 3 2 -\r\n  ;     *    [$b $a]              |  push the result of \"a*b\" (multiply)              | 3 2 *\r\n  ;     nand [$b $a]              |  push the result of \"~(a&b)\" (bitwise nand)       | 3 2 nand\r\n  ;     <<   [$b $a]              |  push the result of \"a<<b\" (signed left-shift)    | 3 2 <<\r\n  ;     >>   [$b $a]              |  push the result of \"a>>b\" (signed right-shift)   | 3 2 >>\r\n\r\n  ; And that's all the primitives!\r\n  ; From just this, we can implement effectively anything, and we more ease than \r\n  ; you'd guess.\r\n\r\n  ; Let's implement some common functions:\r\n\r\n  (>x <x <x) >dup\r\n\r\n  ; This function duplicates the top-of the stack. We can now square numbers as \r\n  ; follows:\r\n\r\n  7 dup * print ; 49\r\n\r\n  ; Here are a handful of stack manipulation functions:\r\n\r\n  (>x >y <x <y) >swap\r\n  (>x >y <y <x <y) >over\r\n  (>x >y >z <y <x <z) >rot\r\n\r\n  ; Let's demonstrate them by example:\r\n\r\n  9 8 7 stack print  ; (7 8 9)\r\n  swap stack print   ; (8 7 9)\r\n  over stack print   ; (7 8 7 9)\r\n  drop stack print   ; (8 7 9)\r\n  rot stack print    ; (9 8 7)\r\n  drop drop drop\r\n\r\n  ; Arithmetic works in Reverse Polish Notation\r\n\r\n  4 5 + 2 * 2 - print ; 16\r\n\r\n  ; Another useful function is \"force\". We can use this function to force \r\n  ; computation of a function on the stack:\r\n\r\n  (>x x) >force\r\n\r\n  ; And here's an example of usage, forcing a function without naming it:\r\n\r\n  (dup *) 8 swap force print ; 64\r\n\r\n  ; We can also define control structures such as if-statements\r\n\r\n  (>cond >true >false cond <false <true rot cswap drop force) >if\r\n\r\n  (5) (4) '#t if print ; 4\r\n  (5) (4) '() if print ; 5\r\n\r\n  ; Writing if-statements backwards is tricky, so we can fix it by defining \r\n  ; \"endif\" which will flip the arguments:\r\n\r\n  (>false >true >cond >if <false <true <cond if) >endif\r\n\r\n  ; Now we can write:\r\n\r\n  <if (1 2 eq)\r\n    (\"true\" print)\r\n    (\"false\" print) ; false\r\n  endif\r\n\r\n  <if (1 1 eq)\r\n    (\"true\" print) ; true\r\n    (\"false\" print)\r\n  endif\r\n\r\n  ; Finally, we'll finish with recursion. Forsp uses the Y-Combinator for recursion\r\n\r\n  (>f (>x (<x x) f) dup force) >Y\r\n\r\n  ; We'll also implement a wrapper called \"rec\" that performs the application Y\r\n\r\n  (>g (<g Y)) >rec\r\n\r\n  ; Now we can implement recursive functions:\r\n\r\n  (>self >list\r\n    <if (<list '() eq) \r\n      0 \r\n      (<list cdr self 1 +)\r\n    endif\r\n  ) rec >length\r\n\r\n  '()      length print ; 0\r\n  '(5)     length print ; 1\r\n  '(8 9)   length print ; 2\r\n  '(1 2 3) length print ; 3\r\n\r\n  ; This concludes the tutorial. You're encouraged to explore the examples to \r\n  ; learn more!\r\n)"
  },
  "extensions": {
    "name": "extensions.fp",
    "cts": "extensions",
    "uts": "lxqb7nn7",
    "content": "(\r\n  ;; Differences found in the forsp-js implementation\r\n\r\n  ; truth is represented by #t instead of just t, following Scheme convention\r\n\r\n  3 4 + 7 eq print ; #t\r\n\r\n  ; All numbers follow JS number semantics\r\n\r\n  ; No low-level memory unsafe operations\r\n\r\n  ;; The following are extensions provided forsp-js , not available in the \r\n  ;; original C implementation\r\n\r\n  ; String values in double quotes\r\n\r\n  \"Hello world\" print;\r\n\r\n  ; import* statement executes another Forsp script file with the given name and \r\n  ; appends the env created by that file into the current env. There is no protection\r\n  ; against recursive import, so you are free to blow your own stack\r\n\r\n  \"./std\" import*\r\n\r\n  \"hello world\" string? print; #t\r\n\r\n  ; import statement executes another Forsp script file with the given name and\r\n  ; pushes a dictionary containing the env created by that file onto the stack\r\n\r\n  \"./std\" import >std\r\n\r\n  ; A dictionary is an ordered list of key-value pairs built from cons shells.\r\n  ; Given that is this is a very common structure in most programming tasks,\r\n  ; there is a special syntax to access its value\r\n\r\n  \"hello world\"\r\n  @(std string?)  ; <-- dictionary get syntax\r\n  force print ;  #t\r\n\r\n  ; the above expression desugars into:\r\n\r\n  \"hello world\"\r\n  <std 'string? dict-get \r\n  force print ; #t\r\n\r\n  ; since dict-get is defined in \"./std\" , the above syntax is only valid after\r\n  ; a `\"./std\" import*`\r\n\r\n\r\n)"
  }
}
